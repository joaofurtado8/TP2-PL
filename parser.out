Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    leia

Grammar

Rule 0     S' -> code
Rule 1     code -> r
Rule 2     code -> code ; r
Rule 3     ciclo -> for var [ n ellipsis n ] code ; endfor
Rule 4     r -> a
Rule 5     r -> ciclo
Rule 6     r -> var atribui a
Rule 7     r -> escreva a_list
Rule 8     a_list -> a
Rule 9     a_list -> a_list , a
Rule 10    n -> nr
Rule 11    n -> - a
Rule 12    n -> a + a
Rule 13    n -> a - a
Rule 14    n -> a * a
Rule 15    n -> a / a
Rule 16    n -> a t a
Rule 17    b -> f
Rule 18    b -> a ou a
Rule 19    b -> a e a
Rule 20    f -> verdadeiro
Rule 21    f -> falso
Rule 22    f -> nao f
Rule 23    a -> var
Rule 24    a -> ( a )
Rule 25    a -> b
Rule 26    a -> n
Rule 27    a -> string

Terminals, with rules where they appear

(                    : 24
)                    : 24
*                    : 14
+                    : 12
,                    : 9
-                    : 11 13
/                    : 15
;                    : 2 3
[                    : 3
]                    : 3
atribui              : 6
e                    : 19
ellipsis             : 3
endfor               : 3
error                : 
escreva              : 7
falso                : 21
for                  : 3
leia                 : 
nao                  : 22
nr                   : 10
ou                   : 18
string               : 27
t                    : 16
var                  : 3 6 23
verdadeiro           : 20

Nonterminals, with rules where they appear

a                    : 4 6 8 9 11 12 12 13 13 14 14 15 15 16 16 18 18 19 19 24
a_list               : 7 9
b                    : 25
ciclo                : 5
code                 : 2 3 0
f                    : 17 22
n                    : 3 3 26
r                    : 1 2

Parsing method: LALR

state 0

    (0) S' -> . code
    (1) code -> . r
    (2) code -> . code ; r
    (4) r -> . a
    (5) r -> . ciclo
    (6) r -> . var atribui a
    (7) r -> . escreva a_list
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (3) ciclo -> . for var [ n ellipsis n ] code ; endfor
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 5
    escreva         shift and go to state 6
    (               shift and go to state 7
    string          shift and go to state 10
    for             shift and go to state 11
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    code                           shift and go to state 1
    r                              shift and go to state 2
    a                              shift and go to state 3
    ciclo                          shift and go to state 4
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 1

    (0) S' -> code .
    (2) code -> code . ; r

    ;               shift and go to state 18


state 2

    (1) code -> r .

    ;               reduce using rule 1 (code -> r .)
    $end            reduce using rule 1 (code -> r .)


state 3

    (4) r -> a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ;               reduce using rule 4 (r -> a .)
    $end            reduce using rule 4 (r -> a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25


state 4

    (5) r -> ciclo .

    ;               reduce using rule 5 (r -> ciclo .)
    $end            reduce using rule 5 (r -> ciclo .)


state 5

    (6) r -> var . atribui a
    (23) a -> var .

    atribui         shift and go to state 26
    ou              reduce using rule 23 (a -> var .)
    e               reduce using rule 23 (a -> var .)
    +               reduce using rule 23 (a -> var .)
    -               reduce using rule 23 (a -> var .)
    *               reduce using rule 23 (a -> var .)
    /               reduce using rule 23 (a -> var .)
    t               reduce using rule 23 (a -> var .)
    ;               reduce using rule 23 (a -> var .)
    $end            reduce using rule 23 (a -> var .)


state 6

    (7) r -> escreva . a_list
    (8) a_list -> . a
    (9) a_list -> . a_list , a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a_list                         shift and go to state 27
    a                              shift and go to state 28
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 7

    (24) a -> ( . a )
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 30
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 8

    (25) a -> b .

    ou              reduce using rule 25 (a -> b .)
    e               reduce using rule 25 (a -> b .)
    +               reduce using rule 25 (a -> b .)
    -               reduce using rule 25 (a -> b .)
    *               reduce using rule 25 (a -> b .)
    /               reduce using rule 25 (a -> b .)
    t               reduce using rule 25 (a -> b .)
    ;               reduce using rule 25 (a -> b .)
    $end            reduce using rule 25 (a -> b .)
    ,               reduce using rule 25 (a -> b .)
    )               reduce using rule 25 (a -> b .)
    ellipsis        reduce using rule 25 (a -> b .)
    ]               reduce using rule 25 (a -> b .)


state 9

    (26) a -> n .

    ou              reduce using rule 26 (a -> n .)
    e               reduce using rule 26 (a -> n .)
    +               reduce using rule 26 (a -> n .)
    -               reduce using rule 26 (a -> n .)
    *               reduce using rule 26 (a -> n .)
    /               reduce using rule 26 (a -> n .)
    t               reduce using rule 26 (a -> n .)
    ;               reduce using rule 26 (a -> n .)
    $end            reduce using rule 26 (a -> n .)
    ,               reduce using rule 26 (a -> n .)
    )               reduce using rule 26 (a -> n .)
    ellipsis        reduce using rule 26 (a -> n .)
    ]               reduce using rule 26 (a -> n .)


state 10

    (27) a -> string .

    ou              reduce using rule 27 (a -> string .)
    e               reduce using rule 27 (a -> string .)
    +               reduce using rule 27 (a -> string .)
    -               reduce using rule 27 (a -> string .)
    *               reduce using rule 27 (a -> string .)
    /               reduce using rule 27 (a -> string .)
    t               reduce using rule 27 (a -> string .)
    ;               reduce using rule 27 (a -> string .)
    $end            reduce using rule 27 (a -> string .)
    ,               reduce using rule 27 (a -> string .)
    )               reduce using rule 27 (a -> string .)
    ellipsis        reduce using rule 27 (a -> string .)
    ]               reduce using rule 27 (a -> string .)


state 11

    (3) ciclo -> for . var [ n ellipsis n ] code ; endfor

    var             shift and go to state 31


state 12

    (17) b -> f .

    ou              reduce using rule 17 (b -> f .)
    e               reduce using rule 17 (b -> f .)
    +               reduce using rule 17 (b -> f .)
    -               reduce using rule 17 (b -> f .)
    *               reduce using rule 17 (b -> f .)
    /               reduce using rule 17 (b -> f .)
    t               reduce using rule 17 (b -> f .)
    ;               reduce using rule 17 (b -> f .)
    $end            reduce using rule 17 (b -> f .)
    ,               reduce using rule 17 (b -> f .)
    )               reduce using rule 17 (b -> f .)
    ellipsis        reduce using rule 17 (b -> f .)
    ]               reduce using rule 17 (b -> f .)


state 13

    (10) n -> nr .

    ou              reduce using rule 10 (n -> nr .)
    e               reduce using rule 10 (n -> nr .)
    +               reduce using rule 10 (n -> nr .)
    -               reduce using rule 10 (n -> nr .)
    *               reduce using rule 10 (n -> nr .)
    /               reduce using rule 10 (n -> nr .)
    t               reduce using rule 10 (n -> nr .)
    ;               reduce using rule 10 (n -> nr .)
    $end            reduce using rule 10 (n -> nr .)
    ,               reduce using rule 10 (n -> nr .)
    )               reduce using rule 10 (n -> nr .)
    ellipsis        reduce using rule 10 (n -> nr .)
    ]               reduce using rule 10 (n -> nr .)


state 14

    (11) n -> - . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 32
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 15

    (20) f -> verdadeiro .

    ou              reduce using rule 20 (f -> verdadeiro .)
    e               reduce using rule 20 (f -> verdadeiro .)
    +               reduce using rule 20 (f -> verdadeiro .)
    -               reduce using rule 20 (f -> verdadeiro .)
    *               reduce using rule 20 (f -> verdadeiro .)
    /               reduce using rule 20 (f -> verdadeiro .)
    t               reduce using rule 20 (f -> verdadeiro .)
    ;               reduce using rule 20 (f -> verdadeiro .)
    $end            reduce using rule 20 (f -> verdadeiro .)
    ,               reduce using rule 20 (f -> verdadeiro .)
    )               reduce using rule 20 (f -> verdadeiro .)
    ellipsis        reduce using rule 20 (f -> verdadeiro .)
    ]               reduce using rule 20 (f -> verdadeiro .)


state 16

    (21) f -> falso .

    ou              reduce using rule 21 (f -> falso .)
    e               reduce using rule 21 (f -> falso .)
    +               reduce using rule 21 (f -> falso .)
    -               reduce using rule 21 (f -> falso .)
    *               reduce using rule 21 (f -> falso .)
    /               reduce using rule 21 (f -> falso .)
    t               reduce using rule 21 (f -> falso .)
    ;               reduce using rule 21 (f -> falso .)
    $end            reduce using rule 21 (f -> falso .)
    ,               reduce using rule 21 (f -> falso .)
    )               reduce using rule 21 (f -> falso .)
    ellipsis        reduce using rule 21 (f -> falso .)
    ]               reduce using rule 21 (f -> falso .)


state 17

    (22) f -> nao . f
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    f                              shift and go to state 33

state 18

    (2) code -> code ; . r
    (4) r -> . a
    (5) r -> . ciclo
    (6) r -> . var atribui a
    (7) r -> . escreva a_list
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (3) ciclo -> . for var [ n ellipsis n ] code ; endfor
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 5
    escreva         shift and go to state 6
    (               shift and go to state 7
    string          shift and go to state 10
    for             shift and go to state 11
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    r                              shift and go to state 34
    a                              shift and go to state 3
    ciclo                          shift and go to state 4
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 19

    (18) b -> a ou . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 35
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 20

    (19) b -> a e . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 36
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 21

    (12) n -> a + . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 37
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 22

    (13) n -> a - . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 38
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 23

    (14) n -> a * . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 39
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 24

    (15) n -> a / . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 40
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 25

    (16) n -> a t . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 41
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 26

    (6) r -> var atribui . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 42
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 27

    (7) r -> escreva a_list .
    (9) a_list -> a_list . , a

    ;               reduce using rule 7 (r -> escreva a_list .)
    $end            reduce using rule 7 (r -> escreva a_list .)
    ,               shift and go to state 43


state 28

    (8) a_list -> a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ,               reduce using rule 8 (a_list -> a .)
    ;               reduce using rule 8 (a_list -> a .)
    $end            reduce using rule 8 (a_list -> a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25


state 29

    (23) a -> var .

    ou              reduce using rule 23 (a -> var .)
    e               reduce using rule 23 (a -> var .)
    +               reduce using rule 23 (a -> var .)
    -               reduce using rule 23 (a -> var .)
    *               reduce using rule 23 (a -> var .)
    /               reduce using rule 23 (a -> var .)
    t               reduce using rule 23 (a -> var .)
    ,               reduce using rule 23 (a -> var .)
    ;               reduce using rule 23 (a -> var .)
    $end            reduce using rule 23 (a -> var .)
    )               reduce using rule 23 (a -> var .)
    ellipsis        reduce using rule 23 (a -> var .)
    ]               reduce using rule 23 (a -> var .)


state 30

    (24) a -> ( a . )
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    )               shift and go to state 44
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25


state 31

    (3) ciclo -> for var . [ n ellipsis n ] code ; endfor

    [               shift and go to state 45


state 32

    (11) n -> - a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    +               reduce using rule 11 (n -> - a .)
    -               reduce using rule 11 (n -> - a .)
    *               reduce using rule 11 (n -> - a .)
    /               reduce using rule 11 (n -> - a .)
    t               reduce using rule 11 (n -> - a .)
    ;               reduce using rule 11 (n -> - a .)
    $end            reduce using rule 11 (n -> - a .)
    ,               reduce using rule 11 (n -> - a .)
    )               reduce using rule 11 (n -> - a .)
    ellipsis        reduce using rule 11 (n -> - a .)
    ]               reduce using rule 11 (n -> - a .)
    ou              shift and go to state 19
    e               shift and go to state 20

  ! ou              [ reduce using rule 11 (n -> - a .) ]
  ! e               [ reduce using rule 11 (n -> - a .) ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! *               [ shift and go to state 23 ]
  ! /               [ shift and go to state 24 ]
  ! t               [ shift and go to state 25 ]


state 33

    (22) f -> nao f .

    ou              reduce using rule 22 (f -> nao f .)
    e               reduce using rule 22 (f -> nao f .)
    +               reduce using rule 22 (f -> nao f .)
    -               reduce using rule 22 (f -> nao f .)
    *               reduce using rule 22 (f -> nao f .)
    /               reduce using rule 22 (f -> nao f .)
    t               reduce using rule 22 (f -> nao f .)
    ;               reduce using rule 22 (f -> nao f .)
    $end            reduce using rule 22 (f -> nao f .)
    ,               reduce using rule 22 (f -> nao f .)
    )               reduce using rule 22 (f -> nao f .)
    ellipsis        reduce using rule 22 (f -> nao f .)
    ]               reduce using rule 22 (f -> nao f .)


state 34

    (2) code -> code ; r .

    ;               reduce using rule 2 (code -> code ; r .)
    $end            reduce using rule 2 (code -> code ; r .)


state 35

    (18) b -> a ou a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ou              reduce using rule 18 (b -> a ou a .)
    +               reduce using rule 18 (b -> a ou a .)
    -               reduce using rule 18 (b -> a ou a .)
    *               reduce using rule 18 (b -> a ou a .)
    /               reduce using rule 18 (b -> a ou a .)
    t               reduce using rule 18 (b -> a ou a .)
    ;               reduce using rule 18 (b -> a ou a .)
    $end            reduce using rule 18 (b -> a ou a .)
    ,               reduce using rule 18 (b -> a ou a .)
    )               reduce using rule 18 (b -> a ou a .)
    ellipsis        reduce using rule 18 (b -> a ou a .)
    ]               reduce using rule 18 (b -> a ou a .)
    e               shift and go to state 20

  ! e               [ reduce using rule 18 (b -> a ou a .) ]
  ! ou              [ shift and go to state 19 ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! *               [ shift and go to state 23 ]
  ! /               [ shift and go to state 24 ]
  ! t               [ shift and go to state 25 ]


state 36

    (19) b -> a e a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ou              reduce using rule 19 (b -> a e a .)
    e               reduce using rule 19 (b -> a e a .)
    +               reduce using rule 19 (b -> a e a .)
    -               reduce using rule 19 (b -> a e a .)
    *               reduce using rule 19 (b -> a e a .)
    /               reduce using rule 19 (b -> a e a .)
    t               reduce using rule 19 (b -> a e a .)
    ;               reduce using rule 19 (b -> a e a .)
    $end            reduce using rule 19 (b -> a e a .)
    ,               reduce using rule 19 (b -> a e a .)
    )               reduce using rule 19 (b -> a e a .)
    ellipsis        reduce using rule 19 (b -> a e a .)
    ]               reduce using rule 19 (b -> a e a .)

  ! ou              [ shift and go to state 19 ]
  ! e               [ shift and go to state 20 ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! *               [ shift and go to state 23 ]
  ! /               [ shift and go to state 24 ]
  ! t               [ shift and go to state 25 ]


state 37

    (12) n -> a + a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    +               reduce using rule 12 (n -> a + a .)
    -               reduce using rule 12 (n -> a + a .)
    t               reduce using rule 12 (n -> a + a .)
    ;               reduce using rule 12 (n -> a + a .)
    $end            reduce using rule 12 (n -> a + a .)
    ,               reduce using rule 12 (n -> a + a .)
    )               reduce using rule 12 (n -> a + a .)
    ellipsis        reduce using rule 12 (n -> a + a .)
    ]               reduce using rule 12 (n -> a + a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    *               shift and go to state 23
    /               shift and go to state 24

  ! ou              [ reduce using rule 12 (n -> a + a .) ]
  ! e               [ reduce using rule 12 (n -> a + a .) ]
  ! *               [ reduce using rule 12 (n -> a + a .) ]
  ! /               [ reduce using rule 12 (n -> a + a .) ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! t               [ shift and go to state 25 ]


state 38

    (13) n -> a - a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    +               reduce using rule 13 (n -> a - a .)
    -               reduce using rule 13 (n -> a - a .)
    t               reduce using rule 13 (n -> a - a .)
    ;               reduce using rule 13 (n -> a - a .)
    $end            reduce using rule 13 (n -> a - a .)
    ,               reduce using rule 13 (n -> a - a .)
    )               reduce using rule 13 (n -> a - a .)
    ellipsis        reduce using rule 13 (n -> a - a .)
    ]               reduce using rule 13 (n -> a - a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    *               shift and go to state 23
    /               shift and go to state 24

  ! ou              [ reduce using rule 13 (n -> a - a .) ]
  ! e               [ reduce using rule 13 (n -> a - a .) ]
  ! *               [ reduce using rule 13 (n -> a - a .) ]
  ! /               [ reduce using rule 13 (n -> a - a .) ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! t               [ shift and go to state 25 ]


state 39

    (14) n -> a * a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    +               reduce using rule 14 (n -> a * a .)
    -               reduce using rule 14 (n -> a * a .)
    *               reduce using rule 14 (n -> a * a .)
    /               reduce using rule 14 (n -> a * a .)
    t               reduce using rule 14 (n -> a * a .)
    ;               reduce using rule 14 (n -> a * a .)
    $end            reduce using rule 14 (n -> a * a .)
    ,               reduce using rule 14 (n -> a * a .)
    )               reduce using rule 14 (n -> a * a .)
    ellipsis        reduce using rule 14 (n -> a * a .)
    ]               reduce using rule 14 (n -> a * a .)
    ou              shift and go to state 19
    e               shift and go to state 20

  ! ou              [ reduce using rule 14 (n -> a * a .) ]
  ! e               [ reduce using rule 14 (n -> a * a .) ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! *               [ shift and go to state 23 ]
  ! /               [ shift and go to state 24 ]
  ! t               [ shift and go to state 25 ]


state 40

    (15) n -> a / a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    +               reduce using rule 15 (n -> a / a .)
    -               reduce using rule 15 (n -> a / a .)
    *               reduce using rule 15 (n -> a / a .)
    /               reduce using rule 15 (n -> a / a .)
    t               reduce using rule 15 (n -> a / a .)
    ;               reduce using rule 15 (n -> a / a .)
    $end            reduce using rule 15 (n -> a / a .)
    ,               reduce using rule 15 (n -> a / a .)
    )               reduce using rule 15 (n -> a / a .)
    ellipsis        reduce using rule 15 (n -> a / a .)
    ]               reduce using rule 15 (n -> a / a .)
    ou              shift and go to state 19
    e               shift and go to state 20

  ! ou              [ reduce using rule 15 (n -> a / a .) ]
  ! e               [ reduce using rule 15 (n -> a / a .) ]
  ! +               [ shift and go to state 21 ]
  ! -               [ shift and go to state 22 ]
  ! *               [ shift and go to state 23 ]
  ! /               [ shift and go to state 24 ]
  ! t               [ shift and go to state 25 ]


state 41

    (16) n -> a t a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

  ! shift/reduce conflict for ou resolved as shift
  ! shift/reduce conflict for e resolved as shift
  ! shift/reduce conflict for + resolved as shift
  ! shift/reduce conflict for - resolved as shift
  ! shift/reduce conflict for * resolved as shift
  ! shift/reduce conflict for / resolved as shift
  ! shift/reduce conflict for t resolved as shift
    ;               reduce using rule 16 (n -> a t a .)
    $end            reduce using rule 16 (n -> a t a .)
    ,               reduce using rule 16 (n -> a t a .)
    )               reduce using rule 16 (n -> a t a .)
    ellipsis        reduce using rule 16 (n -> a t a .)
    ]               reduce using rule 16 (n -> a t a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25

  ! ou              [ reduce using rule 16 (n -> a t a .) ]
  ! e               [ reduce using rule 16 (n -> a t a .) ]
  ! +               [ reduce using rule 16 (n -> a t a .) ]
  ! -               [ reduce using rule 16 (n -> a t a .) ]
  ! *               [ reduce using rule 16 (n -> a t a .) ]
  ! /               [ reduce using rule 16 (n -> a t a .) ]
  ! t               [ reduce using rule 16 (n -> a t a .) ]


state 42

    (6) r -> var atribui a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ;               reduce using rule 6 (r -> var atribui a .)
    $end            reduce using rule 6 (r -> var atribui a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25


state 43

    (9) a_list -> a_list , . a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    a                              shift and go to state 46
    b                              shift and go to state 8
    n                              shift and go to state 9
    f                              shift and go to state 12

state 44

    (24) a -> ( a ) .

    ou              reduce using rule 24 (a -> ( a ) .)
    e               reduce using rule 24 (a -> ( a ) .)
    +               reduce using rule 24 (a -> ( a ) .)
    -               reduce using rule 24 (a -> ( a ) .)
    *               reduce using rule 24 (a -> ( a ) .)
    /               reduce using rule 24 (a -> ( a ) .)
    t               reduce using rule 24 (a -> ( a ) .)
    ;               reduce using rule 24 (a -> ( a ) .)
    $end            reduce using rule 24 (a -> ( a ) .)
    ,               reduce using rule 24 (a -> ( a ) .)
    )               reduce using rule 24 (a -> ( a ) .)
    ellipsis        reduce using rule 24 (a -> ( a ) .)
    ]               reduce using rule 24 (a -> ( a ) .)


state 45

    (3) ciclo -> for var [ . n ellipsis n ] code ; endfor
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    nr              shift and go to state 13
    -               shift and go to state 14
    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    n                              shift and go to state 47
    a                              shift and go to state 48
    b                              shift and go to state 8
    f                              shift and go to state 12

state 46

    (9) a_list -> a_list , a .
    (18) b -> a . ou a
    (19) b -> a . e a
    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a

    ,               reduce using rule 9 (a_list -> a_list , a .)
    ;               reduce using rule 9 (a_list -> a_list , a .)
    $end            reduce using rule 9 (a_list -> a_list , a .)
    ou              shift and go to state 19
    e               shift and go to state 20
    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25


state 47

    (3) ciclo -> for var [ n . ellipsis n ] code ; endfor
    (26) a -> n .

    ellipsis        shift and go to state 49
    +               reduce using rule 26 (a -> n .)
    -               reduce using rule 26 (a -> n .)
    *               reduce using rule 26 (a -> n .)
    /               reduce using rule 26 (a -> n .)
    t               reduce using rule 26 (a -> n .)
    ou              reduce using rule 26 (a -> n .)
    e               reduce using rule 26 (a -> n .)


state 48

    (12) n -> a . + a
    (13) n -> a . - a
    (14) n -> a . * a
    (15) n -> a . / a
    (16) n -> a . t a
    (18) b -> a . ou a
    (19) b -> a . e a

    +               shift and go to state 21
    -               shift and go to state 22
    *               shift and go to state 23
    /               shift and go to state 24
    t               shift and go to state 25
    ou              shift and go to state 19
    e               shift and go to state 20


state 49

    (3) ciclo -> for var [ n ellipsis . n ] code ; endfor
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    nr              shift and go to state 13
    -               shift and go to state 14
    var             shift and go to state 29
    (               shift and go to state 7
    string          shift and go to state 10
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    n                              shift and go to state 50
    a                              shift and go to state 48
    b                              shift and go to state 8
    f                              shift and go to state 12

state 50

    (3) ciclo -> for var [ n ellipsis n . ] code ; endfor
    (26) a -> n .

    ]               shift and go to state 51
    +               reduce using rule 26 (a -> n .)
    -               reduce using rule 26 (a -> n .)
    *               reduce using rule 26 (a -> n .)
    /               reduce using rule 26 (a -> n .)
    t               reduce using rule 26 (a -> n .)
    ou              reduce using rule 26 (a -> n .)
    e               reduce using rule 26 (a -> n .)


state 51

    (3) ciclo -> for var [ n ellipsis n ] . code ; endfor
    (1) code -> . r
    (2) code -> . code ; r
    (4) r -> . a
    (5) r -> . ciclo
    (6) r -> . var atribui a
    (7) r -> . escreva a_list
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (3) ciclo -> . for var [ n ellipsis n ] code ; endfor
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    var             shift and go to state 5
    escreva         shift and go to state 6
    (               shift and go to state 7
    string          shift and go to state 10
    for             shift and go to state 11
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    n                              shift and go to state 9
    code                           shift and go to state 52
    r                              shift and go to state 2
    a                              shift and go to state 3
    ciclo                          shift and go to state 4
    b                              shift and go to state 8
    f                              shift and go to state 12

state 52

    (3) ciclo -> for var [ n ellipsis n ] code . ; endfor
    (2) code -> code . ; r

    ;               shift and go to state 53


state 53

    (3) ciclo -> for var [ n ellipsis n ] code ; . endfor
    (2) code -> code ; . r
    (4) r -> . a
    (5) r -> . ciclo
    (6) r -> . var atribui a
    (7) r -> . escreva a_list
    (23) a -> . var
    (24) a -> . ( a )
    (25) a -> . b
    (26) a -> . n
    (27) a -> . string
    (3) ciclo -> . for var [ n ellipsis n ] code ; endfor
    (17) b -> . f
    (18) b -> . a ou a
    (19) b -> . a e a
    (10) n -> . nr
    (11) n -> . - a
    (12) n -> . a + a
    (13) n -> . a - a
    (14) n -> . a * a
    (15) n -> . a / a
    (16) n -> . a t a
    (20) f -> . verdadeiro
    (21) f -> . falso
    (22) f -> . nao f

    endfor          shift and go to state 54
    var             shift and go to state 5
    escreva         shift and go to state 6
    (               shift and go to state 7
    string          shift and go to state 10
    for             shift and go to state 11
    nr              shift and go to state 13
    -               shift and go to state 14
    verdadeiro      shift and go to state 15
    falso           shift and go to state 16
    nao             shift and go to state 17

    n                              shift and go to state 9
    r                              shift and go to state 34
    a                              shift and go to state 3
    ciclo                          shift and go to state 4
    b                              shift and go to state 8
    f                              shift and go to state 12

state 54

    (3) ciclo -> for var [ n ellipsis n ] code ; endfor .

    ;               reduce using rule 3 (ciclo -> for var [ n ellipsis n ] code ; endfor .)
    $end            reduce using rule 3 (ciclo -> for var [ n ellipsis n ] code ; endfor .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ou in state 41 resolved as shift
WARNING: shift/reduce conflict for e in state 41 resolved as shift
WARNING: shift/reduce conflict for + in state 41 resolved as shift
WARNING: shift/reduce conflict for - in state 41 resolved as shift
WARNING: shift/reduce conflict for * in state 41 resolved as shift
WARNING: shift/reduce conflict for / in state 41 resolved as shift
WARNING: shift/reduce conflict for t in state 41 resolved as shift
